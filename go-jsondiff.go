// A pure GO port of https://github.com/Simperium/jsondiff
package jsondiff

import(
	"strings"
	"log"
	"github.com/sergi/go-diff/diffmatchpatch"
	"encoding/json"
)
/*
Note to self for a little bit later when I get to actually dealing with the deltas... here's how to do it:

	dmp := diffmatchpatch.New()
	delta := dmp.DiffToDelta(dmp.DiffMain("blah blah", "blah foo blah", true))
	log.Printf("From: '%s' to '%s' :: %q", "blah blah", "blah foo blah", delta)
	diff, err := dmp.DiffFromDelta("blah blah", delta)
	if err != nil {
	log.Printf("error making diff from delta: %s", err.Error())
	}
	patch := dmp.PatchMake(diff)
	log.Printf("diff: %#v", diff)
	log.Printf("patch: %#v", patch)
	r, bools := dmp.PatchApply(patch, "blah blah")
	log.Printf("%#v, %s", bools, r)

The above code produces the following output:

	2014/01/31 15:14:01 From: 'blah blah' to 'blah foo blah' :: "=5\t+foo \t=4"
	2014/01/31 15:14:01 diff: []diffmatchpatch.Diff{diffmatchpatch.Diff{Type:0, Text:"blah "}, diffmatchpatch.Diff{Type:1, Text:"foo "}, diffmatchpatch.Diff{Type:0, Text:"blah"}}
	2014/01/31 15:14:01 patch: []diffmatchpatch.Patch{diffmatchpatch.Patch{diffs:[]diffmatchpatch.Diff{diffmatchpatch.Diff{Type:0, Text:"blah "}, diffmatchpatch.Diff{Type:1, Text:"foo "}, diffmatchpatch.Diff{Type:0, Text:"blah"}}, start1:0, start2:0, length1:9, length2:13}}
	2014/01/31 15:14:01 []bool{true}, blah foo blah
*/

// A slice of document changes. Returned by Parse()
type Changes []DocumentChange

// This type is just here to save on placing "map[string] interface{}" all over the codebase.
type Json map[string] interface{}

// Parses a string list of jsondiff changes into an array of changes.  These changes are
// generated by Simperium as objects in a bucket for a user are modified by other connected
// clients. The string from Simperium looke like: %d:c:[...] where %d is the channel that
// You initialized when authorizing against the bucket.
func Parse(changes string) (Changes, error) {
	js := make(Changes,0)
	if err := json.Unmarshal([]byte(changes), &js); err != nil {
		return nil, err
	}
	return js, nil
}

// This struct represents an diff for a document. Sometimes this is a single operation and
// other times more diffs are recursively nested down inside. This only applies to keys 
// inside the main document dict. For top level changes see DocumentChange{}.
type Diff struct {
	Operation string `json:"o"` // +, -, r, I, d, L, dL, O
	Value interface{} `json:"v"`
}

func patchString(from, delta string) (string, error) {
	dmp := diffmatchpatch.New()
	diff, err := dmp.DiffFromDelta(from, delta)
	if err != nil {
		return from, err
	}
	rval, _ := dmp.PatchApply(dmp.PatchMake(diff), from) // TODO: error handling
	return rval, nil
}

// Apply a diff to a part of a document. This only applies to keys inside the main document dict. 
// Never to the entire document. For top level changes see DocumentChange. interface{} is used
// here because we could be looking at anything (bool, string, int, float, list, or dict)
func (d *Diff) apply(data interface{}) interface{} {
	// At this point data could be a number of things
	switch d.Operation {
		case "-": // Delete value at index
			return nil
		case "+": // Insert new value at index
			return d.Value
		case "r": // Replace value at index
			return d.Value
		case "I": // Integer, add the difference to current value
			switch data.(type) {
				case int, int8, int16, int32, int64:
					return (data.(int64)+d.Value.(int64))
				case uint, uint8, uint16, uint32, uint64:
					return (data.(uint64)+d.Value.(uint64))
				case float32, float64:
					return (data.(float64)+d.Value.(float64))
				case nil:
					return d.Value
			}
		case "d": // DiffMatchPatch string at index
			rval, _ := patchString(data.(string), d.Value.(string)) // TODO: error handling
			return rval
		case "dL": // List, apply the diff operations to the current array (w/dmp) (?)
			l := len(data.([]interface{}))
			list := make([]string, l)
			for k, v := range data.([]interface{}) {
				buf, _ := json.Marshal(v) // TODO: error handling
				list[k] = string(buf)
			}
			newList, _ := patchString(strings.Join(list, "\n") + "\n", d.Value.(string))
			newL := make([]interface{}, 0)
			for _, v := range strings.Split(newList, "\n") {
				if len(v) < 1 {
					continue
				}
				i := new(interface{})
				json.Unmarshal([]byte(v), i) // TODO: error handling
				newL = append(newL, *i)
			}
			return newL
		case "L":  // [recurse] List, apply the diff operations to the current array
			// Buggy, requires a schema option to allow simperium to return this op. Unimplimented for now
		case "O":  // [recurse] Object, apply the diff operations to the current object
			doc := data.(map[string]interface {})
			for k, v := range d.Value.(map[string]interface{}) {
				diff := new(Diff)
				diff.Operation = v.(map[string]interface{})["o"].(string)
				diff.Value = v.(map[string]interface{})["v"]
				if part, ok := doc[k]; true == ok {
					if newpart := diff.apply(part); nil != newpart {
						doc[k] = newpart
					} else {
						delete(doc, k)
					}
				} else {
					if newpart := diff.apply(nil); nil != newpart {
						doc[k] = newpart
					} else {
						// non operation delete already missing key from a dict
					}
				}
			}
			return doc
	}
	return data
}

// This represents all of the changes to a single document that are occuring at once. This data
// (excepting Changes which are processed on their own) never deals directly with individual
// parts of the document but rather the document as a whole.
type DocumentChange struct {
	Document string `json:"id"`
	SourceRevision int `json:"sv"`
	ClientId string `json:"clientid"`
	Operation string `json:"o"` // M, -
	Changes map[string] Diff `json:"v"`
	Resultrevision int `json:"ev"`
	CurrentVersion string `json:"cv"`
	ChangesetIds []string `json:"ccds"`
}

// This only applies to the *entire* document object. Never to keys inside the document dict
func (d *DocumentChange) apply(doc Json) Json {
	// { {dict-key}: { "o": {operation}, "v": {value} }
	switch d.Operation {
		case "-": // Delete Document
			return nil
		case "M": // Modify/Create Document
			newDocument := make(Json)
			for k, v := range doc {
				newDocument[k] = v
			}
			for k, change := range d.Changes {
				if v, ok := newDocument[k]; ok == true {
					if r := change.apply(v); r != nil {
						newDocument[k] = r
					} else {
						delete(newDocument, k)
					}
				} else {
					if r := change.apply(nil); r != nil {
						newDocument[k] = r
					} else {
						// non op, delete k, no k. possibly inconsistent?
					}
				}
			}
			return newDocument
		default:
			log.Fatal("jsondiff.DocumentChange.Operation was of unknown value")
			return doc
	}
}

// The main entrypoint for changing a document dict via a documentchange. I suspect that I'll
// reture this and just export the apply function on DocumentChange{}. The main reason this 
// is here is to keep a copy of DiffMatchPatch all to ourselves
type JsonDiff struct {
	dmp *diffmatchpatch.DiffMatchPatch
}

// Apply a DocumentChange{} to a document dict
func (j *JsonDiff) Apply(document Json, change DocumentChange) (Json, error) {
	newDocument := change.apply(document)
	return newDocument, nil
}

// Get a new JsonDiff
func New() *JsonDiff {
	j := new(JsonDiff)
	j.dmp = diffmatchpatch.New()
	return j
}
